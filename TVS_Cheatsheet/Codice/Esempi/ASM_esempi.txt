
asm Semaforo

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	
	enum domain Semaforo = {SA, SB}
	enum domain Colore = {VERDE, GIALLO, ROSSO}
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled coloreSemaforo : Semaforo -> Colore
	
	// monitorate
	monitored comando : Semaforo
	
definitions:

	// -------------------------- Rule definitions --------------------------

	// diventa giallo
	rule r_giallo($s in Semaforo) =
		coloreSemaforo($s) := GIALLO
	
	// diventa verde
	rule r_verde($s in Semaforo) =
		coloreSemaforo($s) := VERDE
		
	// diventa rosso
	rule r_rosso($s in Semaforo) =
		coloreSemaforo($s) := ROSSO

	// -------------------------- CTL --------------------------
	
	// non accade mai che i semafori siano entrambi verdi -> false
	CTLSPEC ag(coloreSemaforo(SA) = VERDE and coloreSemaforo(SB) = VERDE)
	
	// il semaforo 2 può diventare sempre verde (non solo allo stato iniziale) -> true
	CTLSPEC ef(coloreSemaforo(SB) = VERDE)
	
	// se un semaforo è verde allora l’altro è rosso -> true
	CTLSPEC ag((coloreSemaforo(SA) = VERDE implies coloreSemaforo(SB) = ROSSO) and
		(coloreSemaforo(SB) = VERDE implies coloreSemaforo(SA) = ROSSO))
	
	//  se entrambi i semafori sono rossi e viene scelto il semaforo 1, 
	// nello stato successivo il semaforo 1 è verde -> true
	CTLSPEC ag((forall $s in Semaforo with ag(coloreSemaforo($s) = ROSSO) and comando = SA) 
		implies ax(coloreSemaforo(SA) = VERDE))
		
	// il semaforo 1 non può mai essere verde - false
	CTLSPEC ag(coloreSemaforo(SA) != VERDE)
	
	// se SA giallo allora SA sarà sempre rosso in futuro -> falsa
	CTLSPEC ag(coloreSemaforo(SA) = GIALLO implies coloreSemaforo(SB) = VERDE)
	
	// non esiste mai un percorso in cui il SA diventa verde
	CTLSPEC ag(not ef(coloreSemaforo(SA) = VERDE))
	
	
	// -------------------------- Main rule--------------------------

	main rule r_main =
		par
			// entrambi rossi
			if coloreSemaforo(SA) = ROSSO and coloreSemaforo(SB) = ROSSO then
				if comando = SA then
					// comando su SA
					r_verde[SA]
				else
					// comando su SB
					if comando = SB then
						r_verde[SB]
					endif
				endif
			endif
			
			// SA verde, comando su SB rosso
			if coloreSemaforo(SA) = VERDE and coloreSemaforo(SB) = ROSSO then
				if comando = SB then
					r_giallo[SA]
				endif
			endif
			
			// SA giallo, comando su SB rosso
			if coloreSemaforo(SA) = GIALLO and coloreSemaforo(SB) = ROSSO then
				if comando = SB then
					r_rosso[SA]
				endif
			endif
			
			// SB verde, comando su SA rosso
			if coloreSemaforo(SB) = VERDE and coloreSemaforo(SA) = ROSSO then
				if comando = SA then
					r_giallo[SB]
				endif
			endif
			
			// SB giallo, comando su SA rosso
			if coloreSemaforo(SB) = GIALLO and coloreSemaforo(SA) = ROSSO then
				if comando = SA then
					r_rosso[SB]
				endif
			endif
		endpar

// -------------------------- Initial state --------------------------
default init s0:
	function coloreSemaforo($s in Semaforo) = ROSSO


#############################################################################################



asm talkshow

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	
	enum domain Stato = {ASCOLTA, ATTESA, PARLA}
	
	domain TempoParla subsetof Integer
	domain TempoAttesa subsetof Integer
	domain Persone subsetof Integer
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled stato : Persone -> Stato
	controlled inAttesa : Persone -> TempoAttesa
	controlled parla : TempoParla
	controlled microfono : Persone -> Boolean
	
	// monitorate
	monitored vuoleParlare: Persone	
	
definitions:
	// -------------------------- Domain definitions --------------------------
	
	domain Persone = {1 : 6} 
	domain TempoParla = {0 : 5}
	domain TempoAttesa = {0 : 7}

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------

	rule r_gestisciPersona($p in Persone) =
		par
			// sta parlando
			if stato($p) = PARLA then
				if parla = 0 then
					par
						stato($p) := ASCOLTA
						microfono($p) := false
					endpar
				else
					parla := parla -1	
				endif
			endif
			// in attesa
			if stato($p) = ATTESA then
				if inAttesa($p) = 0 then
					stato($p) := ASCOLTA
				else
					inAttesa($p) := inAttesa($p) - 1	
				endif
			endif
			// in ascolto e vuole parlare
			if stato($p) = ASCOLTA and vuoleParlare = $p then
				par
					stato($p) := ATTESA
					inAttesa($p) := 7
				endpar
			endif
		endpar
	
	rule r_scegliNextParla =
		if (forall $p in Persone with stato($p) != PARLA) then
			// nessuno parla
			choose $pers in Persone with stato($pers) = ATTESA and inAttesa($pers) != 0 do
				par
					// in attesa e tempo non finito
					stato($pers) := PARLA
					microfono($pers) := true
					parla := 5
				endpar
		endif
		
	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------

	// -------------------------- CTL --------------------------
	
	// ogni persona prima o poi può parlare
	CTLSPEC (forall $p in Persone with ef(stato($p) = PARLA))
	
	// solo una persona alla volta parla
	CTLSPEC ag( (exist $p in Persone with stato($p) = PARLA) 
		implies (forall $pers in Persone with ($pers != $p and stato($pers) != PARLA))
	)
	
	// solo la persona che parla ha il microfono attivato
	CTLSPEC ag( (exist $p in Persone with microfono($p) = true) 
		implies (forall $pers in Persone with ($pers != $p and microfono($pers) = false) )
	)
	
	// inventate false
	// se una persone parla allora ha il microfono spento
	CTLSPEC ag( (exist $p in Persone with stato($p) = PARLA) 
		implies (microfono($p) = false)
	)
	
	// se una persona parla allora il tempo da cui parla è > 7
	CTLSPEC ag( (exist $p in Persone with stato($p) = PARLA) 
		implies parla > 7
	)
	
	// -------------------------- Main rule--------------------------

	main rule r_main =
		par
			r_gestisciPersona[1]
			r_gestisciPersona[2]
			r_gestisciPersona[3]
			r_gestisciPersona[4]
			r_gestisciPersona[5]
			r_gestisciPersona[6]
			
			r_scegliNextParla[]
		endpar

// -------------------------- Initial state --------------------------
default init s0:
	function stato($p in Persone) = ASCOLTA
	function microfono($a in Persone) = false


#############################################################################################



asm Dado

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 

	enum domain DomGiocatore = {GUNO, GDUE, GTRE, GQUATTRO}
	enum domain DomEsito = {VINCE, PERDE, PATTA}

	domain DomFacciaDado subsetof Integer
	domain DomCredito subsetof Integer
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled turno : DomGiocatore
	controlled credito : DomGiocatore -> DomCredito
	controlled gioca: Boolean	// gioco inizia e continua, false se qualcuno vince/perde
	
	// monitorate
	monitored dado : DomFacciaDado
	
definitions:
	// -------------------------- Domain definitions --------------------------
	domain DomFacciaDado = {1 : 3}
	domain DomCredito = {0 : 12}

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------
	
	// g1 perde e deve cedere il credito a sx
	rule r_cedi($g1 in DomGiocatore, $g2 in DomGiocatore) =
		par
			credito($g1) := credito($g1) - 1
			credito($g2) := credito($g2) + 1
		endpar
	
	// g1 vince e ruba il credito a dx
	rule r_ruba($g1 in DomGiocatore, $g2 in DomGiocatore) =
		par
			credito($g1) := credito($g1) + 1
			credito($g2) := credito($g2) - 1
		endpar
	
	// passaggio di turno
	rule r_passa =
		par
			if turno = GUNO then
				turno := GDUE
			endif
			if turno = GDUE then
				turno := GTRE
			endif
			if turno = GTRE then
				turno := GQUATTRO
			endif
			if turno = GQUATTRO then
				turno := GUNO
			endif
		endpar
		
	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------
	
	// -------------------------- CTL --------------------------
	
	// il massimo che qualsiasi giocatore puo avere è 12 euro
	CTLSPEC (forall $g in DomGiocatore with ag(credito($g) < 13))
	
	// esiste un percorso in cui il primo giocatore perde
	CTLSPEC ef(gioca = false and credito(GUNO) = 0)
	
	// il gioco può continuare all'infinito
	CTLSPEC eg(gioca = true)
	
	// fino a che nessun giocatore ha credito nullo il gioco continua
	CTLSPEC ag((forall $g in DomGiocatore with credito($g) > 0) implies gioca = true)
	
	// *********** inventate ************
	
	// esiste un percorso in cui il secondo giocatore vince
	CTLSPEC ef(credito(GDUE) > 0 and (exist $g in DomGiocatore with credito($g) = 0))
	
	//FALSA: il giocatore due non può avere 5 monete
	CTLSPEC ag(credito(GDUE) != 5)
	
	//un giocatore con credito a zero implica la fine del gioco (non giocare altri round)
	CTLSPEC ag(((credito(GUNO) = 0) or (credito(GDUE) = 0) or (credito(GTRE) = 0) or (credito(GQUATTRO) = 0)) 
			implies ax(not gioca)
	)
	
	// -------------------------- Main rule--------------------------

	main rule r_main =
	// se gioco attivo
		if gioca then
			// se qualche giocatore ho credito nullo
			if credito(GUNO) = 0 or credito(GDUE) = 0 or credito(GTRE) = 0 or credito(GQUATTRO) = 0 then
				gioca := false
			else
				par
					// perde, cede denaro
					if dado = 1 then
						par
							// se GUNO perde cede a GQUATTRO
							if turno = GUNO then
								r_cedi[GUNO, GQUATTRO]
							endif
							// se GDUE perde cede a GUNO
							if turno = GDUE then
								r_cedi[GDUE, GUNO]
							endif
							// se GTRE perde cede a GDUE
							if turno = GTRE then
								r_cedi[GTRE, GDUE]
							endif
							// se GQUATTRO perde cede a GTRE
							if turno = GQUATTRO then
								r_cedi[GQUATTRO, GTRE]
							endif
						endpar
					endif
					
					// patta
	//				if dado = 2 then
	//					// nulla
	//				endif
					
					// vince, prende denaro
					if dado = 3 then
						par
							// se GUNO vince ruba a GDUE
							if turno = GUNO then
								r_ruba[GUNO, GDUE]
							endif
							// se GDUE vince ruba a GUNOGTRE
							if turno = GDUE then
								r_ruba[GDUE, GTRE]
							endif
							// se GTRE vince ruba a GQUATTRO
							if turno = GTRE then
								r_ruba[GTRE, GQUATTRO]
							endif
							// se GQUATTRO vince ruba a GUNO
							if turno = GQUATTRO then
								r_ruba[GQUATTRO, GUNO]
							endif
						endpar
					endif
				
				// passa ad ogni turno
				r_passa[]
				endpar
			endif
		endif
			
		
// -------------------------- Initial state --------------------------
default init s0:
	function gioca = true
	function credito($g in DomGiocatore) = 3
	function turno = GUNO


#############################################################################################



/* Ciclo semaforo: rosso - verde - giallo - rosso
 * Da rosso diventa verde solo se arriva una richiesta.
 * Cambia stato solo se è passato il timer
 */

asm Semaforo

import StandardLibrary 
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains --------------------------

	enum domain Stato = {ROSSO | VERDE | GIALLO}
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled statoSemaforo : Stato
	
	// monitorate
	monitored richiesta : Boolean		// richiedo = true, altrimenti false
	monitored timerPassed : Boolean		// cambia stato solo se timer passato (extra)
	
definitions:
	// -------------------------- Domain definitions --------------------------
	// non serve se non ho dei subset di un dominio

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------
	rule r_verde =
		statoSemaforo := VERDE
	
	rule r_rosso =
		statoSemaforo := ROSSO

	rule r_giallo =
		statoSemaforo := GIALLO

	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------
	
	// -------------------------- CTL --------------------------
	
	// non può mai passare a verde direttamente da rosso
	CTLSPEC ag(statoSemaforo = ROSSO implies ax(statoSemaforo != VERDE))
	// falsa, se riciesta deve succedere
	
	// se rosso resta sempre rosso, a meno che ci sia una riciesta
	CTLSPEC ag(statoSemaforo = ROSSO implies aw(statoSemaforo = ROSSO, richiesta = true))
	// aw() perché la richiesta potrebbe non avvenire mai
	
	// se c'è una richiesta, allora prima o poi diventa verde
	CTLSPEC ag((statoSemaforo = ROSSO and richiesta = true) implies af(statoSemaforo = VERDE))
	// oppure: se giallo non controllo la richiesta, però dopo timer diventa rosso, se poi ho richiesta -> passa a verde (VERA)
	CTLSPEC ag((richiesta = true) implies af(statoSemaforo = VERDE))
	// oppure: se in giallo, poi rosso, poi richiesta -> diventa verde (TRUE)
	CTLSPEC ag((richiesta = true) implies ef(statoSemaforo = VERDE))
	
	// in quasiasi istante, prima o poi potrebbe diventare verde
	CTLSPEC ef(statoSemaforo = VERDE)
	CTLSPEC ag(ef(statoSemaforo = VERDE))
	
	// -------------------------- Main rule--------------------------
	
	main rule r_main =
			// se rosso e richiesta
			if statoSemaforo = ROSSO and richiesta then
					r_verde[]
			else
				// se verde e timer passato
				if statoSemaforo = VERDE and timerPassed then
					r_giallo[]
				else
					// se giallo e timer passato
					if statoSemaforo = GIALLO and timerPassed then
						r_rosso[]
					endif
				endif
			endif

// -------------------------- Initial state --------------------------

default init s0:
	function statoSemaforo = ROSSO


#####################################################################################



/* il forno può essere: 
 * in stanby (chiuso e spento)
 * con la porta aperta, ma spento
 * oppure acceso, ma la porta deve essere chiusa.
 * Se forno acceso, e la porta viene aperta, il forno si spegne
 */

asm Forno

import StandardLibrary 
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	enum domain Stato = {ACCESO | SPENTO}
	enum domain StatoPorta = {APERTA| CHIUSA}
	
	// -------------------------- Functions --------------------------
	// controllate
	controlled statoForno : Stato
	controlled statoPorta : StatoPorta
	
	// monitorate
	monitored comandoApertura : Boolean		// aperto = true, chiuso = false
	monitored accendi : Boolean
	monitored spegni : Boolean
	
definitions:
	// -------------------------- Domain definitions --------------------------
	// non serve se non ho dei subset di un dominio

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------
	rule r_accendi =
		statoForno := ACCESO
	
	rule r_spegni =
		statoForno := SPENTO

	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------
	
	// -------------------------- CTL --------------------------
	
	// se forno acceso la porta è sempre chiusa
	CTLSPEC ag(statoForno = ACCESO implies statoPorta = CHIUSA)
	
	// prima o poi si può accendere in qualsiasi momento in futuro
	CTLSPEC ef(statoForno = ACCESO)
	
	// la porta può essere aperta dopo che il forno viene acceso
	CTLSPEC eg(statoForno = ACCESO implies ef(statoPorta = APERTA))
	
	// quando accceso, la porta rimane chiusa fino a quando rimane acceso (usa until)
	CTLSPEC ag(statoForno = ACCESO implies a(statoPorta = CHIUSA, statoForno = ACCESO))
	
	// -------------------------- Main rule--------------------------
	main rule r_Main =
		par
			// gestine stato forno
			if statoForno = SPENTO and statoPorta = CHIUSA and accendi then
				// posso accendere il forno
				r_accendi[]
			else
				if statoForno = ACCESO and spegni then
				// forno acceso -> porta chiusa, spengo il forno
					r_spegni[]
				endif
			endif
			
			// gestine stato porta
			if statoForno = SPENTO then
				// posso aprire solo se nel frattempo non lo sto anche accendendo
				if comandoApertura and not accendi then
					// posso aprire la porta perché il forno è spento
					statoPorta := APERTA
				else
					// porta già aperta, la chiudo
					statoPorta := CHIUSA
				endif
			else
				// forno acceso, non potrei aprire la porta, se la apro il forno si spegne
				if comandoApertura then
					par
						statoPorta := APERTA
						r_spegni[]
					endpar
				endif
			endif
		endpar

// -------------------------- Initial state --------------------------
default init s0:
	function statoForno = SPENTO
	function statoPorta = CHIUSA


################################################################################



asm ArrayLuci

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	
	enum domain Stato = {ACCESO, SPENTO}
	enum domain Comando = {NONE, TOGGLE, ALLOFF}
	
	domain Luci subsetof Integer
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled statoLuce : Luci -> Stato
	
	// monitorate
	monitored toggle: Luci
	monitored comando: Comando
	
	derived allOff: Boolean
	
definitions:
	// -------------------------- Domain definitions --------------------------
	
	domain Luci = {0 : 9}

	// -------------------------- Function definitions --------------------------
	
	function allOff =
		(forall $r in Luci with statoLuce($r) = SPENTO)

	// -------------------------- Rule definitions --------------------------
	
	// cambia stato luce
	rule r_toggle =
		if statoLuce(toggle) = ACCESO then
			statoLuce(toggle) := SPENTO
		else
			statoLuce(toggle) := ACCESO
		endif
	
	rule r_allOff = 
		forall $i in Luci do statoLuce($i) := SPENTO

	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------

	// -------------------------- CTL --------------------------
	
	// è sempre possibile avere tutte le lampadine spente 
	CTLSPEC ag( (forall $r in Luci with ag(statoLuce($r) = SPENTO)) )	// false a meno di essere allo start
	
	// se tutte spente, finché non toggle, restano tutte spente
	CTLSPEC ag((forall $r in Luci with ag(statoLuce($r) = SPENTO) and comando != TOGGLE) 
		implies ag(statoLuce($r) = SPENTO))
	
	// se toggle una luce, nello satto successivo questo cambia
	CTLSPEC ag((forall $r in Luci with ag(statoLuce($r) = SPENTO) and comando = TOGGLE) 
		implies ex(statoLuce($r) = ACCESO))
	
	// -------------------------- Main rule--------------------------

	main rule r_main =
		if comando = ALLOFF then
			r_allOff[]
		else
			if comando = TOGGLE then
				r_toggle[]
			endif
		endif

// -------------------------- Initial state --------------------------
default init s0:
	function statoLuce($l in Luci) = ACCESO


#########################################################################



asm Silos

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	
	enum domain ActiveMachine = {GRU | NASTRO}
	
	domain Grano subsetof Integer
	domain GranoGru subsetof Integer
	domain Cilindro subsetof Integer
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled grano: Cilindro -> Grano	// quanto grano in un cilindro
	
	// monitorate
	monitored machine: ActiveMachine	// quale macchina è attiva
	monitored granoGru: GranoGru		// quanto grano rilascia la gru
	monitored cilindroGru: Cilindro		// in quale cilindro
	
definitions:
	// -------------------------- Domain definitions --------------------------
	
	domain Grano = {0 : 12}
	domain GranoGru = {1 : 5}
	domain Cilindro = {1 : 3}

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------

	rule r_usaGru =
		if (grano(cilindroGru) + granoGru) <= 10 then
			grano(cilindroGru) := grano(cilindroGru) + granoGru
		endif

	rule r_usaNastro($c in Cilindro) =
		if grano($c) <= 1 then
			grano($c) := 0
		else
			grano($c) := grano($c) - 2
		endif

	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------

	// -------------------------- CTL --------------------------
	
	// Tutti i cilindri non hanno mai più di 10 quintali di grano 
	CTLSPEC (forall $c in Cilindro with ag(grano($c) <= 10))
	
	// Se nastro attivo, nello stato successivo tutti i cilindri avranno max 8 quintali
	CTLSPEC ag( machine = NASTRO
		implies (forall $c in Cilindro with ax(grano($c) <= 8)) )
	
	// Se primo cilindro vuoto, finché non si attiva la gru, esso rimane vuoto (usa weak until)
	CTLSPEC ag( grano(1) = 0 implies aw(grano(1) = 0, machine = GRU) )
	
	// -------------------------- Main rule--------------------------

	main rule r_main =
		if machine = GRU then
			r_usaGru[]
		else
			par
				r_usaNastro[1]
				r_usaNastro[2]
				r_usaNastro[3]
			endpar
		endif

// -------------------------- Initial state --------------------------
default init s0:
	function grano($c in Cilindro) =  1


#####################################################################################


asm SemaforiWatchdog

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	
	enum domain Stato = {VERDE, ROSSO, LAMPEGGIA}
	
	domain Time subsetof Integer
	domain Prob subsetof Integer
	
	// -------------------------- Functions --------------------------

	// controllate
	
	controlled statoMacchine: Stato
	controlled statoPedoni: Stato
	controlled timerPedoni: Time
	controlled timerMacchine: Time
	
	// monitorate
	monitored pulsante: Boolean
//	monitored guasto : Boolean
	
definitions:
	// -------------------------- Domain definitions --------------------------
	
	domain Time = {0 : 3}
	domain Prob = {0 : 1}

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------

	rule r_rosso = 
		if statoMacchine = VERDE then
			statoMacchine := ROSSO
		else
			if statoPedoni = VERDE then
				statoPedoni := ROSSO
			endif
		endif
		
		
	rule r_verde = 
		if timerMacchine = 3 then
			// verde per le macchine
			par
				statoMacchine := VERDE
				timerMacchine := 0
			endpar
		else
			if timerPedoni = 3 then
				// verde per i pedoni
				par
					statoPedoni := VERDE
					timerPedoni := 0
				endpar
			endif
		endif
	
	// guasto si o no	
//	rule r_guasto = 
//		choose $scelta in Prob with ($scelta = 0 or $scelta = 1) do
//			if $scelta = 0 then
//				par
//					guasto := true
//					statoMacchine := LAMPEGGIA
//					statoPedoni := LAMPEGGIA
//				endpar	
//			else
//				guasto := false
//			endif
	

	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------

	// -------------------------- CTL --------------------------

	
	// -------------------------- Main rule--------------------------

	main rule r_main =
		par
			 if pulsante then
			 	par
				 	r_rosso[]			// semaforo auto rosso
				 	timerPedoni := 1	// inizio attesa pedoni
			 	endpar
		 	else
		 		if statoPedoni = VERDE then
			 		par
			 			r_rosso[]			// semaforo pedoni rosso
					 	timerPedoni := 1	// inizio attesa macchine
			 		endpar
		 		endif
			 endif
			 
			 if timerPedoni > 0 then
			 	if timerPedoni = 3 then
			 		r_verde[]		// verde per i pedoni
		 		else
		 			timerPedoni := timerPedoni + 1	// continua attesa pedoni
			 	endif
			 endif
			 
			 if timerMacchine > 0 then
			 	if timerMacchine = 3 then
			 		r_verde[]		// verde per le macchine
		 		else
		 			timerMacchine := timerMacchine + 1	// continua attesa macchine
			 	endif
			 endif
			 
			 // modello guasto
//			 if guasto then
//			 	r_guasto[]
//			 endif
		 endpar
		

// -------------------------- Initial state --------------------------
default init s0:
	function statoMacchine = VERDE
	function statoPedoni = ROSSO
	function timerPedoni = 0
	function timerMacchine = 0



####################################################################################



asm Telecamere

import StandardLibrary
import LTLlibrary
import CTLlibrary


signature:
	// -------------------------- Domains -------------------------- 
	
	enum domain Stato = {ACCESA, SPENTA}
	enum domain Comando = {ACCENDI, SPEGNI}
	
	domain Telecamera subsetof Integer
	
	// -------------------------- Functions --------------------------

	// controllate
	controlled statoTelecamera : Telecamera -> Stato
	
	// monitorate
	monitored toggle: Telecamera
	monitored comando: Comando
	
definitions:
	// -------------------------- Domain definitions --------------------------
	
	domain Telecamera = {0 : 2}

	// -------------------------- Function definitions --------------------------
	// solo funzioni derivate

	// -------------------------- Rule definitions --------------------------

	rule r_spegni =
		if statoTelecamera(toggle) = ACCESA then
			if (exist $t in Telecamera with statoTelecamera($t) = ACCESA and $t != toggle) then
				// se resta un'eltra telecamera accesa
				statoTelecamera(toggle) := SPENTA
			endif
		endif
		
	rule r_accendi =
		if statoTelecamera(toggle) = SPENTA then
			statoTelecamera(toggle) := ACCESA
		endif
	
	// -------------------------- Invariants --------------------------
	
	// -------------------------- LTL --------------------------

	// -------------------------- CTL --------------------------

	
	// -------------------------- Main rule--------------------------

	main rule r_main =
		if comando = SPEGNI then
			r_spegni[]
		else
			if comando = ACCENDI then
				r_accendi[]
			endif
		endif

// -------------------------- Initial state --------------------------
default init s0:
	function statoTelecamera($t in Telecamera) = ACCESA


##############################################################################


// versione corretta da me

asm talkshow

import StandardLibrary
import CTLlibrary

signature:
	// DOMAINS
	enum domain Stato = {ASCOLTO | ATTESA | PARLA}
	domain TempoParla subsetof Integer
	domain TempoAttesa subsetof Integer
	domain Persone subsetof Integer
	
	// faccio fuori la moderatirce controlled moderatrice: Stato
	controlled stato: Persone -> Stato
	controlled inAttesa : Persone -> TempoAttesa
	controlled parla : TempoParla // tempo in cui chi sta parlando parla
//	controlled microfono: Persone -> Boolean// chi parla 
	controlled microfono: Persone 
	monitored vuoleParlare: Persone // chi vuole intervanire
	
	derived nessunoParla : Boolean
	
	static maxTempoParla : TempoParla
	
definitions:
	// DOMAIN DEFINITIONS
	domain Persone = {1:3} // {1:6} 
	domain TempoParla = {0:5}
	domain TempoAttesa = {0:7}
	
	function maxTempoParla = 5
	function nessunoParla = (forall $p in Persone with stato($p) != PARLA)

	rule r_scegliNextParla =	
	    if nessunoParla then 
	    	choose $p in Persone with stato($p) = ATTESA and inAttesa($p) != 0 do
	    	par
	    		stato($p) := PARLA
				//microfono($p) := true
				microfono := $p
				parla := maxTempoParla //max parla 
	    	endpar
	    endif
	
	rule r_gestisciPersona($p in Persone) =	
		par			
			if stato($p) = PARLA then
				if parla = 0 then par
					stato($p) := ASCOLTO
					//microfono($p) := false
					microfono := undef
				endpar
				else
				   parla := parla -1
				endif				  
			endif
			if stato($p) = ATTESA then
				if inAttesa($p) = 0 then 
					stato($p) := ASCOLTO
				else
				   inAttesa($p) := inAttesa($p) -1
				endif
			endif				  			
			if stato($p) = ASCOLTO and vuoleParlare = $p then // probability
			  par
			   stato($p) := ATTESA
			   inAttesa($p) := 7
			  endpar 
			endif
		endpar


	// P1 una persona prima o poi può parlare
	//CTLSPEC ef(stato(1) = PARLA)
	CTLSPEC (forall $p in Persone with ef(stato($p) = PARLA))
	// P2 solo una persona alla volta parla
	//CTLSPEC (forall $p in Persone with ag(stato($p) = PARLA) implies forall ...)
	CTLSPEC ag(stato(1) = PARLA implies  stato(2) != PARLA and stato(3) != PARLA) 
	
	// stato(microfono) non posso usarlo
	// 
	CTLSPEC (forall $p in Persone with ag(isDef(microfono) and microfono = $p implies stato($p) = PARLA))
	
	invariant inv_mic over microfono: (forall $p in Persone with microfono = $p implies stato($p) = PARLA)
	
	main rule r_Moderatore=
	par
		r_gestisciPersona[1]
		r_gestisciPersona[2]
		r_gestisciPersona[3]
//		r_gestisciPersona[4]
//		r_gestisciPersona[5]
//		r_gestisciPersona[6]
		r_scegliNextParla[]
	endpar
		
		
	
// INITIAL STATE
default init s0:
	function stato($a in Persone) = ASCOLTO
	//function microfono($a in Persone) = false
	function microfono = undef


#################################################################################################################


asm mercoledi

import StandardLibrary
import LTLlibrary
import CTLlibrary

signature:

enum domain DStatoSemaforo = {VERDE,ROSSO,LAMPEGGIO}
enum domain DSemaforo = {AUTO,PEDONE}
enum domain D5050 = {GUASTO,NOGUASTO}
domain DSecondi subsetof Integer

controlled statoSemaforo: DSemaforo -> DStatoSemaforo 
controlled timer: DSemaforo -> DSecondi
controlled conta: DSemaforo -> Boolean
monitored pulsante: Boolean


derived isSemaforiGuasti: Boolean

definitions:
	
	domain DSecondi = {0:3}
	
	function isSemaforiGuasti = (forall $s in DSemaforo with statoSemaforo($s) != LAMPEGGIO )

rule r_rottura =
		par
			statoSemaforo(PEDONE) := LAMPEGGIO
			statoSemaforo(AUTO) := LAMPEGGIO
			conta(PEDONE) := false
			conta(AUTO) := false
			timer(PEDONE) := 0
			timer(AUTO) := 0
		endpar
		
main rule r_main = 
	par
		if conta(PEDONE) and timer(PEDONE) < 3 then
			timer(PEDONE):= timer(PEDONE) + 1
		endif
		
		if conta(AUTO)  and timer(AUTO) < 3 then
			timer(AUTO):= timer(AUTO) + 1
		endif
	
		if pulsante and statoSemaforo(PEDONE) = ROSSO and statoSemaforo(AUTO) = VERDE then 
			par
				statoSemaforo(AUTO) := ROSSO
				timer(AUTO) := 0
				timer(PEDONE) := 0
				conta(AUTO) := false
				conta(PEDONE) := true
			endpar
		endif
		
		if conta(PEDONE) and timer(PEDONE) = 3 then
			choose $p in D5050 with true do
				if $p = NOGUASTO then
					par
						statoSemaforo(PEDONE) := VERDE
						statoSemaforo(AUTO) := ROSSO
						conta(PEDONE) := false
						timer(PEDONE) := 0
						conta(AUTO) := true
						timer(AUTO) := 0
					endpar
				else
					par
						statoSemaforo(PEDONE) := LAMPEGGIO
						statoSemaforo(AUTO) := LAMPEGGIO
						conta(PEDONE) := false
						conta(AUTO) := false
						timer(PEDONE) := 0
						timer(AUTO) := 0
					endpar
				endif
		endif
		
		if conta(AUTO) and timer(AUTO) = 3 then
			choose $f in D5050 with true do
				if $f = NOGUASTO then
				par
					statoSemaforo(PEDONE) := ROSSO
					statoSemaforo(AUTO) := VERDE
					conta(AUTO) := false
					conta(PEDONE) := false
					timer(AUTO) := 0
					timer(PEDONE) := 0
				endpar
			else
				par
					statoSemaforo(PEDONE) := LAMPEGGIO
					statoSemaforo(AUTO) := LAMPEGGIO
					conta(PEDONE) := false
					conta(AUTO) := false
					timer(PEDONE) := 0
					timer(AUTO) := 0
				endpar
			endif
		endif
		
		if statoSemaforo(AUTO) = ROSSO and statoSemaforo(PEDONE) = ROSSO and conta(AUTO) = false and conta(PEDONE) = false then
			statoSemaforo(AUTO) := VERDE
		endif
		
	endpar
	
	
	
default init s0:
	 function statoSemaforo($s in DSemaforo) = ROSSO
	 function conta($s in DSemaforo) = false
	 function timer($s in DSemaforo) = 0
	

################################################################################################################################


asm test

import StandardLibrary
import LTLlibrary
import CTLlibrary

signature:

enum domain Pizza = {TONNO, CIPOLLE, QUATTROFORM}
enum domain Soldi = {CINQUE, DIECI, CINQUANTA}
domain Quantita subsetof Integer

controlled disponibile: Pizza -> Quantita
controlled erogato: Pizza
monitored soldo: Soldi

derived isTonnodisponibile: Boolean
static maxSoldi: Soldi

definitions:
	
	domain Quantita = {0:10}
	
	function maxSoldi = CINQUANTA
	function isTonnodisponibile = (forall $p in Pizza with $p = TONNO and disponibile($p) > 0 )
	
//	LTLSPEC g(disponibile(TONNO) = 0 implies g(disponibile(TONNO) = 0))
//  LTLSPEC g(disponibile(CIPOLLE) >= 7)
  LTLSPEC (forall $p in Pizza with g(disponibile($p)>=0))

//	CTLSPEC not ef(disponibile(QUATTROFORM) = 0)
//	CTLSPEC a(disponibile(TONNO) >0 , disponibile(TONNO) = 0)
//	CTLSPEC ag(disponibile(CIPOLLE) >= 0)
    
	
//	invariant inv_soldoValido over soldo: soldo = CINQUE or soldo = DIECI or soldo = CINQUANTA 

//rule r_coninput($p in Pizza) = .... 
//poi vanno chiamate con r_coninput[...] oppure [] se non  li ha
main rule r_main = 
	if soldo = CINQUE then 
		if disponibile(TONNO) > 0 then par
			erogato := TONNO
			disponibile(TONNO) := disponibile(TONNO) -1
		endpar
		endif
	else 
		if soldo = DIECI then 
				if disponibile(CIPOLLE) > 0 then par
					erogato := CIPOLLE
					disponibile(CIPOLLE) := disponibile(CIPOLLE) -1
					endpar
				endif
		else
			choose $p in Pizza with $p != TONNO do
				if disponibile($p) >0 then par
					erogato := $p
					disponibile($p) := disponibile($p) -1
					endpar
				endif
		endif
	endif

//nel caso in cui io debba gestire due cose insieme (tipo stato forno e porta del forno)
//devo fare main rule: par {if else endif} {if else endif} endpar
//cosi da "separare" i due if 

default init s0:
	function disponibile($f in Pizza) = 10
	
/* NON PUO MAI PASSARE A VERDE DIRETTAMENTE DA ROSSO
 * DA ROSSO NON PUOI PASSARE A VERDE DIRETTAMENTE
 * CTLSPEC ag(semaforo=ROSSO implies ax(semaforo != VERDE))
 * 
 * QUANDO E' ROSSO RIMARRA SEMPRE ROSSO A MENO CHE CI SIA UNA RICHIESTA
 * CTLSPEC ag(semaforo=ROSSO implies aw(semaforo = ROSSO,richiesta)
 * /////e' un weak-until perche potrebbe anche non arrivare mai la richiesta
 * /////l' until invece prima o poi deve essere "verificato"
 * 
 * SE C'E' UNA RICHIESTA ALLORA PRIMA O POI DIVENTA VERDE
 * CTLSPEC ag((richiesta and semaforo=ROSSO) implies af(semaforo=GREEN))
 * /////e' af e non ef perche il cambio e' certo, anche se non so quando lo fara
 * ///// potrebbe essere ef se non fosse certo che prima o poi diventera verde
 * 
 * IN QUALSIASI ISTANTE PRIMA O POI POTREBBE DIVENTARE VERDE
 * CTLSPEC ag(ef(semaforo=VERDE))
 * ///// oppure anche solo ef(...), ma nel secondo caso potrei 
 * ///// catturare un solo VERDE, mentre con ag dico che sempre potrei finire in un
 * ///// verde
 *
 * LA PORTA RIMANE CHIUSA FINO A QUANDO RIMANE ACCESO
 * CTLSPEC a(porta=chiusa,stato=acceso)
 */

 ########################################################################################################################


 module MAPEpatterns

import StandardLibrary
import LTLlibrary

export *

signature:
	derived correctStep: Prod(Boolean, Boolean, Powerset(Boolean)) -> Boolean
	derived both: Prod(Boolean, Boolean) -> Boolean
	derived requires: Prod(Boolean, Powerset(Boolean)) -> Boolean
	derived ensures: Prod(Boolean, Powerset(Boolean)) -> Boolean

definitions:
	function correctStep($p in Boolean, $q in Boolean, $s in Powerset(Boolean)) =
		$p implies u((forall $e in $s with not($e)), $q)

	function both($p in Boolean, $q in Boolean) =
		($p implies (f($q) or o($q))) and ($q implies (f($p) or o($p)))

	function requires($p in Boolean, $s in Powerset(Boolean)) =
		$p implies (forall $e in $s with o($e))

	function ensures($p in Boolean, $s in Powerset(Boolean)) =
		$p implies (forall $e in $s with f($e))


#####################################################################################################################




